#!/usr/bin/env node

const fs = require("fs");
const path = require("path");

console.log("üîë Injecting verifying key into Stylus contract...");

// Read the verification key (from project root)
const vkPath = path.join(
  __dirname,
  "..",
  "circuits",
  "build",
  "verification_key.json"
);
if (!fs.existsSync(vkPath)) {
  console.error("‚ùå Verification key not found. Run circuit build first.");
  process.exit(1);
}

const vk = JSON.parse(fs.readFileSync(vkPath, "utf8"));
console.log("‚úÖ Loaded verification key");

// Convert VK to raw bytes format for Rust
function pointToBytes(point) {
  const x = BigInt(point[0]).toString(16).padStart(64, "0");
  const y = BigInt(point[1]).toString(16).padStart(64, "0");
  return `[${hexToByteArray(x).join(", ")}, ${hexToByteArray(y).join(", ")}]`;
}

function g2PointToBytes(point) {
  // EIP-197: Fp2 element (a*i + b) encoded as (a, b)
  // Our JSON has [[x_real, x_imag], [y_real, y_imag], [1, 0]]
  // JSON represents real + imag*i, but EIP-197 wants a*i + b encoded as (a, b)
  // So we need: [x_imag, x_real, y_imag, y_real] for EVM format
  const x_real = BigInt(point[0][0]).toString(16).padStart(64, "0");
  const x_imag = BigInt(point[0][1]).toString(16).padStart(64, "0");
  const y_real = BigInt(point[1][0]).toString(16).padStart(64, "0");
  const y_imag = BigInt(point[1][1]).toString(16).padStart(64, "0");

  return `[${hexToByteArray(x_imag).join(", ")}, ${hexToByteArray(x_real).join(
    ", "
  )}, ${hexToByteArray(y_imag).join(", ")}, ${hexToByteArray(y_real).join(
    ", "
  )}]`;
}

function hexToByteArray(hex) {
  const bytes = [];
  for (let i = 0; i < hex.length; i += 2) {
    bytes.push(`0x${hex.substr(i, 2)}`);
  }
  return bytes;
}

// Generate Rust code for hardcoded VK
const alphaG1 = pointToBytes(vk.vk_alpha_1);
const betaG2 = g2PointToBytes(vk.vk_beta_2);
const gammaG2 = g2PointToBytes(vk.vk_gamma_2);
const deltaG2 = g2PointToBytes(vk.vk_delta_2);

let gammaAbcG1 = "[";
for (let i = 0; i < vk.IC.length; i++) {
  gammaAbcG1 += pointToBytes(vk.IC[i]);
  if (i < vk.IC.length - 1) gammaAbcG1 += ", ";
}
gammaAbcG1 += "]";

// Generate the complete verifying_key.rs file with only constants (no storage)
const rustVkCode = `// Auto-generated verifying key constants
// Generated by scripts/inject-vk.js - DO NOT EDIT MANUALLY

use crate::{G1Point, G2Point, VerifyingKey};

// Hardcoded verifying key constants for gas optimization
pub const VK_ALPHA_G1: G1Point = ${alphaG1};
pub const VK_BETA_G2: G2Point = ${betaG2};
pub const VK_GAMMA_G2: G2Point = ${gammaG2};
pub const VK_DELTA_G2: G2Point = ${deltaG2};
pub const VK_GAMMA_ABC_G1: &[G1Point] = &${gammaAbcG1};

// Function to get verifying key using compile-time constants (no storage reads)
pub fn get_verifying_key() -> VerifyingKey {
    VerifyingKey {
        alpha_g1: VK_ALPHA_G1,
        beta_g2: VK_BETA_G2,
        gamma_g2: VK_GAMMA_G2,
        delta_g2: VK_DELTA_G2,
        gamma_abc_g1: VK_GAMMA_ABC_G1.to_vec(),
    }
}`;

// Write the verifying_key.rs file
const vkFilePath = path.join(
  __dirname,
  "..",
  "stylus-contracts",
  "src",
  "verifying_key.rs"
);
fs.writeFileSync(vkFilePath, rustVkCode);

console.log("‚úÖ Generated stylus-contracts/src/verifying_key.rs");
console.log("üéâ Contract is ready for compilation and deployment!");